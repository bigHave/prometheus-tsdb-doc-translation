# Prometheus TSDB (Part 4): Persistent Block and its Index

原文地址：https://ganeshvernekar.com/blog/prometheus-tsdb-persistent-block-and-its-index/

## 简介

在前3篇文章中，我们已经讨论过了和（内存中的）Head block 有关的事情（在撰写本文时，又增加了更多有关 Head 的事情）。本文我们将深入探讨在磁盘上的持久化 block。

## 持久化 block 是什么 & 在何时创建的

磁盘上的一个 block 是由一定时间范围内的 chunks 和其索引组成的。它是一个包括了多个文件的目录。每个 block 有一个唯一的 ID，也就是 [ULID](https://github.com/oklog/ulid)。

block 有一个有趣的属性：其中的 samples 是**不可变**的。如果你想增加/删除/更新 samples，你必须带上必需的改动重新写整个 block，而新的 block 有新的 ID。这两个 blocks 之间没有任何联系。我们通过墓碑对 block 做删除操作，而不会涉及到 samples，这是因为在每次删除请求时重写 block 并不是一个合理的办法；对此我们将会在本文中做更多讨论。

在第1篇文章中我们看到，当 Head block 被时间跨度达到 `chunkRange*3/2` 的数据填充时，我们将第一个 `chunkRange` 的数据转化为一个持久化 block。

![](https://ganeshvernekar.com/blog/img/tsdb8.svg)

![](https://ganeshvernekar.com/blog/img/tsdb9.svg)

在 blocks 的上下文中，我们将 `chunkRange` 称为 `blockRange`。在 Prometheus 中，从 Head 上切下来的第一个 block 时间跨度默认是 `2h`。

TSDB 的整体图如下：

![](https://ganeshvernekar.com/blog/img/tsdb1.svg)

当 blocks 变老时，多个 blocks 会被压缩（或者合并）以形成一个新的更大的 block，而老的 blocks 会被删掉。所以共有2种创建 block 的方法：从 Head 和从已存在的 blocks。我们将在后续文章中讨论压缩。

## block 的内容

一个 block 由4部分组成：

1. `meta.json`（文件）：block的元数据。

2. `chunks`（目录）：包含原始的 chunks，没有 chunks 的任何元数据。

3. `index`（文件）：block 的索引。

4. `tombstones`（文件）：删除的标记，用来在查询 block 时排除一些 samples。

用 `01EM6Q6A1YPX4G9TEB20J22B2R` 这个 block ID 作为例子，下面是该 block 的文件：

```
data
├── 01EM6Q6A1YPX4G9TEB20J22B2R
|   ├── chunks
|   |   ├── 000001
|   |   └── 000002
|   ├── index
|   ├── meta.json
|   └── tombstones
├── chunks_head
|   ├── 000001
|   └── 000002
└── wal
    ├── checkpoint.000003
    |   ├── 000000
    |   └── 000001
    ├── 000004
    └── 000005
```

接下来深入看看其中每一部分。

---

### 1. `meta.json`

此文件包含了 block 所有必需的元数据。这里有一个示例：

```
{
    "ulid": "01EM6Q6A1YPX4G9TEB20J22B2R",
    "minTime": 1602237600000,
    "maxTime": 1602244800000,
    "stats": {
        "numSamples": 553673232,
        "numSeries": 1346066,
        "numChunks": 4440437
    },
    "compaction": {
        "level": 1,
        "sources": [
            "01EM65SHSX4VARXBBHBF0M0FDS",
            "01EM6GAJSYWSQQRDY782EA5ZPN"
        ]
    },
    "version": 1
}
```

`version` 表示如何解析元数据文件。

尽管目录名称被设置为 ULID，但只有在 `meta.json` 文件中的 `ulid` 字段才会被当作有效的 ID，而目录名称可以是任意的。

`minTime` 和 `maxTime` 是 block 中所有 chunks 的最小和最大的绝对时间戳。

`stats` 表示了 block 中的序列数量，samples 数量和 chunks 数量。

`compaction` 表示了该 block 的历史。`level` 表示该 block 经过了多少代。 `sources` 表示该 block 是从哪些 blocks 创建而来的（也就是，哪些 blocks 合并得到了这个 block）。如果它是从 Head block 创建而来的，那么 `sources` 会被设置为它自己（也就是 `01EM6Q6A1YPX4G9TEB20J22B2R`）。

---

### 2. `chunks`

`chunks` 目录包含了一系列连续编号的文件，这点和 WAL/checkpoint/head chunks 类似。每个文件**最大 512MiB**。目录中单个文件的格式如下：

```
┌──────────────────────────────┐
│  magic(0x85BD40DD) <4 byte>  │
├──────────────────────────────┤
│    version(1) <1 byte>       │
├──────────────────────────────┤
│    padding(0) <3 byte>       │
├──────────────────────────────┤
│ ┌──────────────────────────┐ │
│ │         Chunk 1          │ │
│ ├──────────────────────────┤ │
│ │          ...             │ │
│ ├──────────────────────────┤ │
│ │         Chunk N          │ │
│ └──────────────────────────┘ │
└──────────────────────────────┘
```

这看起来和[内存映射的 head chunks 文件](https://ganeshvernekar.com/blog/prometheus-tsdb-mmapping-head-chunks-from-disk/#the-file)很相似。 `magic` 数字表征了这个文件是一个 chunks 文件。`version` 表明如何解析该文件。 `padding` 是为了未来的 headers 预留的。接下来就是 chunks 的列表。

单个 chunk 的格式如下：

```
┌───────────────┬───────────────────┬──────────────┬────────────────┐
│ len <uvarint> │ encoding <1 byte> │ data <bytes> │ CRC32 <4 byte> │
└───────────────┴───────────────────┴──────────────┴────────────────┘
```

这看起来又和[磁盘上内存映射的 head chunks](https://ganeshvernekar.com/blog/prometheus-tsdb-mmapping-head-chunks-from-disk/#chunks)相似，除了它没有 `series ref`, `mint`, `maxt` 外。对于 Head chunks，我们需要这些额外信息来在启动时重建在内存中的索引。但是在当前这个持久化 blocks 的场景中，这些额外信息在 `index` 中，因为索引才是它最终该归属的地方，所以此处我们不需要这些信息。

为了访问这些 chunks，我们再次需要用到在第3篇文章中讨论过的 chunk 引用。再重复一遍：**引用的长度是8个字节**。前4个字节表示 chunk 所在的文件的编号，后4个字节表示在该文件中 chunk 的起始位置（也就是 `len` 的首字节）。举个例子，如果 chunk 在文件 `00093` 中并且该 chunk 的`len`从该文件的 `1234` 字节偏移量开始，那么这个 chunk 的引用就是 `(92 << 32) | 1234`（位左移然后做位或运算）。文件名是从1开始的，而 chunks 引用是从0开始的。所以在计算 chunk 引用时 `00093` 要转化为 `92`。

这是描述 `chunks` 格式的文档[链接](https://github.com/prometheus/prometheus/blob/main/tsdb/docs/format/chunks.md)。

---

### 3. `index`

索引包含了查询 block 的数据需要的所有信息。它不和任何其他 blocks 或者外部的实体共享任何数据，这使得无依赖地读/查询 block 成为可能。

这里的索引是“**反向索引**”，在文档索引中也有着广泛应用。Fabian 在[他的博客](https://fabxc.org/tsdb/)中论及了反向索引，因此我将跳过这个话题，毕竟这篇文章已经很长了。

如下是索引的一个高层次的视图：

```
┌────────────────────────────┬─────────────────────┐
│ magic(0xBAAAD700) <4b>     │ version(1) <1 byte> │
├────────────────────────────┴─────────────────────┤
│ ┌──────────────────────────────────────────────┐ │
│ │                 Symbol Table                 │ │
│ ├──────────────────────────────────────────────┤ │
│ │                    Series                    │ │
│ ├──────────────────────────────────────────────┤ │
│ │                 Label Index 1                │ │
│ ├──────────────────────────────────────────────┤ │
│ │                      ...                     │ │
│ ├──────────────────────────────────────────────┤ │
│ │                 Label Index N                │ │
│ ├──────────────────────────────────────────────┤ │
│ │                   Postings 1                 │ │
│ ├──────────────────────────────────────────────┤ │
│ │                      ...                     │ │
│ ├──────────────────────────────────────────────┤ │
│ │                   Postings N                 │ │
│ ├──────────────────────────────────────────────┤ │
│ │              Label Offset Table              │ │
│ ├──────────────────────────────────────────────┤ │
│ │             Postings Offset Table            │ │
│ ├──────────────────────────────────────────────┤ │
│ │                      TOC                     │ │
│ └──────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
```

和其他文件一样，`magic` 数字标识了该文件是一个索引文件。`version` 表示如何解析该文件。索引的入口点是 `TOC`，代表目录（Table Of Contents）。所以我们将首先从 `TOC` 开始，然后学习索引的其他部分。

---

#### A. `TOC`

```
┌─────────────────────────────────────────┐
│ ref(symbols) <8b>                       │ -> Symbol Table
├─────────────────────────────────────────┤
│ ref(series) <8b>                        │ -> Series
├─────────────────────────────────────────┤
│ ref(label indices start) <8b>           │ -> Label Index 1
├─────────────────────────────────────────┤
│ ref(label offset table) <8b>            │ -> Label Offset Table
├─────────────────────────────────────────┤
│ ref(postings start) <8b>                │ -> Postings 1
├─────────────────────────────────────────┤
│ ref(postings offset table) <8b>         │ -> Postings Offset Table
├─────────────────────────────────────────┤
│ CRC32 <4b>                              │
└─────────────────────────────────────────┘
```

它表示了索引中各个组件的起始位置（文件中的字节偏移量）。我已经标注了每个引用指向的是上面索引格式中的哪个组件。下一个组件的起始位置也表明了当前组件的结束位置。如果有任何引用是 `0`，那表示对应的部分在该索引中不存在，因此在读时应该跳过。

由于 `TOC` 的大小是固定的，索引文件的最后52字节可以被当作是 `TOC`。

在后文中你将会注意到，每个组件都有着它自己的校验码，即 `CRC32` 来检查底层数据的完整性。

---

#### B. `Symbol Table`

此部分有该 block 中所有序列的标签对中的**去重**后的字符串的**有序列表**。例如，有序列是 `{a="y", x="b"}`，那么符号是 `"a", "b", "x", "y"`。

```
┌────────────────────┬─────────────────────┐
│ len <4b>           │ #symbols <4b>       │
├────────────────────┴─────────────────────┤
│ ┌──────────────────────┬───────────────┐ │
│ │ len(str_1) <uvarint> │ str_1 <bytes> │ │
│ ├──────────────────────┴───────────────┤ │
│ │                . . .                 │ │
│ ├──────────────────────┬───────────────┤ │
│ │ len(str_n) <uvarint> │ str_n <bytes> │ │
│ └──────────────────────┴───────────────┘ │
├──────────────────────────────────────────┤
│ CRC32 <4b>                               │
└──────────────────────────────────────────┘
```
 
`len <4b>` 是该部分的字节数，`#symbols` 是符号数。接下来是 `#symbols` 个utf-8编码的字符串，每个字符串由表示它长度的前缀和它的原始字节组成。校验码（`CRC32`）是用于数据完整性的。

索引的其他部分的字符串可以引用这个符号表，这样可以显著地减少索引大小。符号在该文件中起始的字节偏移量（即 `len(str_i)` 的起始位置）就是对应的符号的引用，这可以替代实际的字符串用在其他地方。当你需要实际的字符串时，可以使用这个偏移量来从这张表里获取。

---

#### C. `Series`

此部分包含了该 block 中所有的序列信息的列表。序列是根据它们的标签集按照字典序排列的。

```
┌───────────────────────────────────────┐
│ ┌───────────────────────────────────┐ │
│ │   series_1                        │ │
│ ├───────────────────────────────────┤ │
│ │                 . . .             │ │
│ ├───────────────────────────────────┤ │
│ │   series_n                        │ │
│ └───────────────────────────────────┘ │
└───────────────────────────────────────┘
```

每个序列条目是16字节对齐的，这意味着每个序列起始的字节偏移量是可被16整除的。因此我们把序列的 ID 设置为 `offset/16`，这里的 offset 指向序列条目的起始位置。这个 ID 用来引用该序列，当你想访问该序列时，你可以用 `ID*16` 来得到它在索引中的位置。

由于序列是根据它们的标签集按照字典序排列的，序列ID的有序列表意味着序列标签集的有序列表。

来看一个在索引中使很多人疑惑的问题：什么是 **posting** ？上述的序列 ID 就是*一个 posting*。所以当我们在 Prometheus TSDB 的上下文中说到 posting 时，它指的就是序列 ID。但是为什么用 posting 这个词？我猜是：用反向索引做文档和它的词语的索引时，文档 ID 常被称为索引中的 “posting”。你可以将一个序列想成是一个文档，序列中的一对标签-值想做是文档中的词语。序列 ID -> 文档 ID，文档 ID -> posting，序列 ID -> posting。

每个条目中有序列的标签集和指向属于该序列的所有 chunks 的引用（这个引用就是 `chunks` 目录的那个）。

```
┌──────────────────────────────────────────────────────┐
│ len <uvarint>                                        │
├──────────────────────────────────────────────────────┤
│ ┌──────────────────────────────────────────────────┐ │
│ │            labels count <uvarint64>              │ │
│ ├──────────────────────────────────────────────────┤ │
│ │  ┌────────────────────────────────────────────┐  │ │
│ │  │ ref(l_i.name) <uvarint32>                  │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ ref(l_i.value) <uvarint32>                 │  │ │
│ │  └────────────────────────────────────────────┘  │ │
│ │                       ...                        │ │
│ ├──────────────────────────────────────────────────┤ │
│ │            chunks count <uvarint64>              │ │
│ ├──────────────────────────────────────────────────┤ │
│ │  ┌────────────────────────────────────────────┐  │ │
│ │  │ c_0.mint <varint64>                        │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ c_0.maxt - c_0.mint <uvarint64>            │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ ref(c_0.data) <uvarint64>                  │  │ │
│ │  └────────────────────────────────────────────┘  │ │
│ │  ┌────────────────────────────────────────────┐  │ │
│ │  │ c_i.mint - c_i-1.maxt <uvarint64>          │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ c_i.maxt - c_i.mint <uvarint64>            │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ ref(c_i.data) - ref(c_i-1.data) <varint64> │  │ │
│ │  └────────────────────────────────────────────┘  │ │
│ │                       ...                        │ │
│ └──────────────────────────────────────────────────┘ │
├──────────────────────────────────────────────────────┤
│ CRC32 <4b>                                           │
└──────────────────────────────────────────────────────┘
```

起始的 `len` 和结尾的 `CRC32` 和前述的相同。序列条目以其中的标签-值对的数量开始，即 `labels count`，接着是字典序排列（按照标签名）的标签-值对。这里我们使用对符号表的符号引用，而不是把实际的字符串存起来。假如序列是 `{a="y", x="b"}`，那么它的序列条目会包括对 `"a", "y", "x", "b"` 的符号引用（以相同顺序）。

接下来是 `chunks` 目录中属于这个序列的 chunks 的数量（`chunks count`）。再接着是被索引的 chunks 的一系列元数据，包括 chunk 的最小时间（第一个 sample 的时间戳）和最大时间（最后一个 sample 的时间戳）和它在 `chunks` 目录中的引用。这些是按照 chunks 的 `mint` 排序的。如果你细看上面的格式，我们实际上是用对前一个的差值来存储 `mint` 和 `maxt` 的（相同 chunk 的mint 或者前一个 chunk 的maxt）。这会减少 chunk 元数据的大小，因为这占据了索引大小的一大部分。

在索引中存储 `mint` 和 `maxt` 使得查询可以跳过那些不在查询时间范围的 chunks。这和从磁盘做内存映射的 Head chunks 不同，那里 `mint` 和 `maxt` 是和 chunks 一起的，为了在启动期间重建 Head 的内存中索引。

---

#### D. `Label Offset Table` 和 `Label Index i`

这两项是耦合在一起的，所以我们放在一起讨论。`Label Index i` 指的是索引中的 `Label Index 1 ... Label Index N`；我们将讨论单个 `Label Index i` 条目。

**这两项已经不再使用了**；**写**它们是为了保持向后兼容，但是在最新版本的 Prometheus 中已经**不再读**它们了。然而，理解这些部分的用处还是有用的，我们将在下一部分看到它们被什么所取代。

这些部分的目的在于对标签名的可能的值做索引。例如，如果我们有两个序列 `{a="b1", x="y1"}` 和 `{a="b2", x="y2"}`，这部分使得我们可以得出，对于标签名 `a` 的可能的值是 `[b1, b2]`，而对于 `x` 可能的值是 `[y1, y2]`。这种格式也可以索引得出对于标签名 `(a, x)` 可能的值是 `[(b1, y1), (b2, y2)]`，但我们并没有在 Prometheus 中使用。

##### `Label Index i`

这是单个 `Label Index i` 条目的格式，我们有多个这种条目的序列，不过没有特定的顺序。

```
┌───────────────┬────────────────┬────────────────┐
│ len <4b>      │ #names <4b>    │ #entries <4b>  │
├───────────────┴────────────────┴────────────────┤
│ ┌─────────────────────────────────────────────┐ │
│ │ ref(value_0) <4b>                           │ │
│ ├─────────────────────────────────────────────┤ │
│ │ ...                                         │ │
│ ├─────────────────────────────────────────────┤ │
│ │ ref(value_n) <4b>                           │ │
│ └─────────────────────────────────────────────┘ │
│                      . . .                      │
├─────────────────────────────────────────────────┤
│ CRC32 <4b>                                      │
└─────────────────────────────────────────────────┘
```

根据上面的例子，这帮助我们存储 `[b1, b2], [y1, y2], [(b1, y1), (b2, y2)]` 列表，而每个列表在索引中都有其自己的条目。`len` 和 `CRC32` 和之前一样。

`#names` 是值对应的标签名的数量。例如，如果我们在对 `a` 或者 `x` 做索引，`#names` 就是1.而如果我们在对 `(a, x)` 做索引，即2个标签名，那么 `#names` 就是2。

`#entries` 是标签名的可能的值的数量。如果名称是 `a` 或者 `x`，甚至是 `(a, x)`，`#entries` 是2，因为它们每个都有2个可能的值。

接着的是 `#names * #entries` 个对值符号的引用。

以 `[b1, b2]` 为例：

```
┌────┬───┬───┬─────────┬─────────┬───────┐
│ 16 │ 1 │ 2 │ ref(b1) | ref(b2) | CRC32 |
└────┴───┴───┴─────────┴─────────┴───────┘
```

以 `[(b1, y1), (b2, y2)]` 为例：

```
┌────┬───┬───┬─────────┬─────────┬─────────┬─────────┬───────┐
│ 24 │ 2 │ 2 │ ref(b1) | ref(y1) │ ref(b2) | ref(y2) | CRC32 |
└────┴───┴───┴─────────┴─────────┴─────────┴─────────┴───────┘
```

##### `Label Offset Table`

#### E. `Postings Offset Table` 和 `Postings i`

##### `Postings i`

##### `Postings Offset Table`


### 4. `tombstones`

## 尾声


## 代码参考
