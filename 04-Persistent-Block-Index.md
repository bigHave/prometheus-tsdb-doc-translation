# Prometheus TSDB (Part 4): Persistent Block and its Index

原文地址：https://ganeshvernekar.com/blog/prometheus-tsdb-persistent-block-and-its-index/

## 简介

在前3篇文章中，我们已经讨论过了和（内存中的）Head block 有关的事情（在撰写本文时，又增加了更多有关 Head 的事情）。本文我们将深入探讨在磁盘上的持久化 block。

## 持久化 block 是什么 & 在何时创建的

磁盘上的一个 block 是由一定时间范围内的 chunks 和其索引组成的。它是一个包括了多个文件的目录。每个 block 有一个唯一的 ID，也就是 [ULID](https://github.com/oklog/ulid)。

block 有一个有趣的属性：其中的 samples 是**不可变**的。如果你想增加/删除/更新 samples，你必须带上必需的改动重新写整个 block，而新的 block 有新的 ID。这两个 blocks 之间没有任何联系。我们通过墓碑对 block 做删除操作，而不会涉及到 samples，这是因为在每次删除请求时重写 block 并不是一个合理的办法；对此我们将会在本文中做更多讨论。

在第1篇文章中我们看到，当 Head block 被时间跨度达到 `chunkRange*3/2` 的数据填充时，我们将第一个 `chunkRange` 的数据转化为一个持久化 block。

![](https://ganeshvernekar.com/blog/img/tsdb8.svg)

![](https://ganeshvernekar.com/blog/img/tsdb9.svg)

在 blocks 的上下文中，我们将 `chunkRange` 称为 `blockRange`。在 Prometheus 中，从 Head 上切下来的第一个 block 时间跨度默认是 `2h`。

TSDB 的整体图如下：

![](https://ganeshvernekar.com/blog/img/tsdb1.svg)

当 blocks 变老时，多个 blocks 会被压缩（或者合并）以形成一个新的更大的 block，而老的 blocks 会被删掉。所以共有2种创建 block 的方法：从 Head 和从已存在的 blocks。我们将在后续文章中讨论压缩。

## block 的内容

一个 block 由4部分组成：

1. `meta.json`（文件）：block的元数据。

2. `chunks`（目录）：包含原始的 chunks，没有 chunks 的任何元数据。

3. `index`（文件）：block 的索引。

4. `tombstones`（文件）：删除的标记，用来在查询 block 时排除一些 samples。

用 `01EM6Q6A1YPX4G9TEB20J22B2R` 这个 block ID 作为例子，下面是该 block 的文件：

```
data
├── 01EM6Q6A1YPX4G9TEB20J22B2R
|   ├── chunks
|   |   ├── 000001
|   |   └── 000002
|   ├── index
|   ├── meta.json
|   └── tombstones
├── chunks_head
|   ├── 000001
|   └── 000002
└── wal
    ├── checkpoint.000003
    |   ├── 000000
    |   └── 000001
    ├── 000004
    └── 000005
```

接下来深入看看其中每一部分。

---

### 1. `meta.json`

此文件包含了 block 所有必需的元数据。这里有一个示例：

```
{
    "ulid": "01EM6Q6A1YPX4G9TEB20J22B2R",
    "minTime": 1602237600000,
    "maxTime": 1602244800000,
    "stats": {
        "numSamples": 553673232,
        "numSeries": 1346066,
        "numChunks": 4440437
    },
    "compaction": {
        "level": 1,
        "sources": [
            "01EM65SHSX4VARXBBHBF0M0FDS",
            "01EM6GAJSYWSQQRDY782EA5ZPN"
        ]
    },
    "version": 1
}
```

`version` 表示如何解析元数据文件。

尽管目录名称被设置为 ULID，但只有在 `meta.json` 文件中的 `ulid` 字段才会被当作有效的 ID，而目录名称可以是任意的。

`minTime` 和 `maxTime` 是 block 中所有 chunks 的最小和最大的绝对时间戳。

`stats` 表示了 block 中的序列数量，samples 数量和 chunks 数量。

`compaction` 表示了该 block 的历史。`level` 表示该 block 经过了多少代。 `sources` 表示该 block 是从哪些 blocks 创建而来的（也就是，哪些 blocks 合并得到了这个 block）。如果它是从 Head block 创建而来的，那么 `sources` 会被设置为它自己（也就是 `01EM6Q6A1YPX4G9TEB20J22B2R`）。

---

### 2. `chunks`

`chunks` 目录包含了一系列连续编号的文件，这点和 WAL/检查点/head chunks 类似。每个文件**最大 512MiB**。目录中单个文件的格式如下：

```
┌──────────────────────────────┐
│  magic(0x85BD40DD) <4 byte>  │
├──────────────────────────────┤
│    version(1) <1 byte>       │
├──────────────────────────────┤
│    padding(0) <3 byte>       │
├──────────────────────────────┤
│ ┌──────────────────────────┐ │
│ │         Chunk 1          │ │
│ ├──────────────────────────┤ │
│ │          ...             │ │
│ ├──────────────────────────┤ │
│ │         Chunk N          │ │
│ └──────────────────────────┘ │
└──────────────────────────────┘
```

这看起来和[内存映射的 head chunks 文件](https://ganeshvernekar.com/blog/prometheus-tsdb-mmapping-head-chunks-from-disk/#the-file)很相似。 `magic` 数字表征了这个文件是一个 chunks 文件。`version` 表明如何解析该文件。 `padding` 是为了未来的 headers 预留的。接下来就是 chunks 的列表。

单个 chunk 的格式如下：

```
┌───────────────┬───────────────────┬──────────────┬────────────────┐
│ len <uvarint> │ encoding <1 byte> │ data <bytes> │ CRC32 <4 byte> │
└───────────────┴───────────────────┴──────────────┴────────────────┘
```

这看起来又和[磁盘上内存映射的 head chunks](https://ganeshvernekar.com/blog/prometheus-tsdb-mmapping-head-chunks-from-disk/#chunks)相似，除了它没有 `series ref`, `mint`, `maxt` 外。对于 Head chunks，我们需要这些额外信息来在启动时重建在内存中的索引。但是在当前这个持久化 blocks 的场景中，这些额外信息在 `index` 中，因为索引才是它最终该归属的地方，所以此处我们不需要这些信息。

为了访问这些 chunks，我们再次需要用到在第3篇文章中讨论过的 chunk 引用。再重复一遍：**引用的长度是8个字节**。前4个字节表示 chunk 所在的文件的编号，后4个字节表示在该文件中 chunk 的起始位置（也就是 `len` 的首字节）。举个例子，如果 chunk 在文件 `00093` 中并且该 chunk 的`len`从该文件的 `1234` 字节偏移量开始，那么这个 chunk 的引用就是 `(92 << 32) | 1234`（位左移然后做位或运算）。文件名是从1开始的，而 chunks 引用是从0开始的。所以在计算 chunk 引用时 `00093` 要转化为 `92`。

这是描述 `chunks` 格式的文档[链接](https://github.com/prometheus/prometheus/blob/main/tsdb/docs/format/chunks.md)。

---

### 3. `index`

索引包含了查询 block 的数据需要的所有信息。它不和任何其他 blocks 或者外部的实体共享任何数据，这使得无依赖地读/查询 block 成为可能。

这里的索引是“**反向索引**”，在文档索引中也有着广泛应用。Fabian 在[他的博客](https://fabxc.org/tsdb/)中论及了反向索引，因此我将跳过这个话题，毕竟这篇文章已经很长了。

如下是索引的一个高层次的视图：

```
┌────────────────────────────┬─────────────────────┐
│ magic(0xBAAAD700) <4b>     │ version(1) <1 byte> │
├────────────────────────────┴─────────────────────┤
│ ┌──────────────────────────────────────────────┐ │
│ │                 Symbol Table                 │ │
│ ├──────────────────────────────────────────────┤ │
│ │                    Series                    │ │
│ ├──────────────────────────────────────────────┤ │
│ │                 Label Index 1                │ │
│ ├──────────────────────────────────────────────┤ │
│ │                      ...                     │ │
│ ├──────────────────────────────────────────────┤ │
│ │                 Label Index N                │ │
│ ├──────────────────────────────────────────────┤ │
│ │                   Postings 1                 │ │
│ ├──────────────────────────────────────────────┤ │
│ │                      ...                     │ │
│ ├──────────────────────────────────────────────┤ │
│ │                   Postings N                 │ │
│ ├──────────────────────────────────────────────┤ │
│ │              Label Offset Table              │ │
│ ├──────────────────────────────────────────────┤ │
│ │             Postings Offset Table            │ │
│ ├──────────────────────────────────────────────┤ │
│ │                      TOC                     │ │
│ └──────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
```

和其他文件一样，`magic` 数字标识了该文件是一个索引文件。`version` 表示如何解析该文件。索引的入口点是 `TOC`，代表目录（Table Of Contents）。所以我们将首先从 `TOC` 开始，然后学习索引的其他部分。

---

#### A. `TOC`

```
┌─────────────────────────────────────────┐
│ ref(symbols) <8b>                       │ -> Symbol Table
├─────────────────────────────────────────┤
│ ref(series) <8b>                        │ -> Series
├─────────────────────────────────────────┤
│ ref(label indices start) <8b>           │ -> Label Index 1
├─────────────────────────────────────────┤
│ ref(label offset table) <8b>            │ -> Label Offset Table
├─────────────────────────────────────────┤
│ ref(postings start) <8b>                │ -> Postings 1
├─────────────────────────────────────────┤
│ ref(postings offset table) <8b>         │ -> Postings Offset Table
├─────────────────────────────────────────┤
│ CRC32 <4b>                              │
└─────────────────────────────────────────┘
```

它表示了索引中各个组件的起始位置（文件中的字节偏移量）。我已经标注了每个引用指向的是上面索引格式中的哪个组件。下一个组件的起始位置也表明了当前组件的结束位置。如果有任何引用是 `0`，那表示对应的部分在该索引中不存在，因此在读时应该跳过。

由于 `TOC` 的大小是固定的，索引文件的最后52字节可以被当作是 `TOC`。

在后文中你将会注意到，每个组件都有着它自己的校验码，即 `CRC32` 来检查底层数据的完整性。

---

#### B. `Symbol Table`

此部分有该 block 中所有序列的标签对中的**去重**后的字符串的**有序列表**。例如，有序列是 `{a="y", x="b"}`，那么符号是 `"a", "b", "x", "y"`。

```
┌────────────────────┬─────────────────────┐
│ len <4b>           │ #symbols <4b>       │
├────────────────────┴─────────────────────┤
│ ┌──────────────────────┬───────────────┐ │
│ │ len(str_1) <uvarint> │ str_1 <bytes> │ │
│ ├──────────────────────┴───────────────┤ │
│ │                . . .                 │ │
│ ├──────────────────────┬───────────────┤ │
│ │ len(str_n) <uvarint> │ str_n <bytes> │ │
│ └──────────────────────┴───────────────┘ │
├──────────────────────────────────────────┤
│ CRC32 <4b>                               │
└──────────────────────────────────────────┘
```
 
`len <4b>` 是该部分的字节数，`#symbols` 是符号数。接下来是 `#symbols` 个utf-8编码的字符串，每个字符串由表示它长度的前缀和它的原始字节组成。校验码（`CRC32`）是用于数据完整性的。

索引的其他部分的字符串可以引用这个符号表，这样可以显著地减少索引大小。符号在该文件中起始的字节偏移量（即 `len(str_i)` 的起始位置）就是对应的符号的引用，这可以替代实际的字符串用在其他地方。当你需要实际的字符串时，可以使用这个偏移量来从这张表里获取。

---

#### C. `Series`

此部分包含了该 block 中所有的序列信息的列表。序列是根据它们的标签集按照字典序排列的。

```
┌───────────────────────────────────────┐
│ ┌───────────────────────────────────┐ │
│ │   series_1                        │ │
│ ├───────────────────────────────────┤ │
│ │                 . . .             │ │
│ ├───────────────────────────────────┤ │
│ │   series_n                        │ │
│ └───────────────────────────────────┘ │
└───────────────────────────────────────┘
```

每个序列条目是16字节对齐的，这意味着每个序列起始的字节偏移量是可被16整除的。因此我们把序列的 ID 设置为 `offset/16`，这里的 offset 指向序列条目的起始位置。这个 ID 用来引用该序列，当你想访问该序列时，你可以用 `ID*16` 来得到它在索引中的位置。

由于序列是根据它们的标签集按照字典序排列的，序列ID的有序列表意味着序列标签集的有序列表。

来看一个在索引中使很多人疑惑的问题：什么是 **posting** ？上述的序列 ID 就是*一个 posting*。所以当我们在 Prometheus TSDB 的上下文中说到 posting 时，它指的就是序列 ID。但是为什么用 posting 这个词？我猜是：用反向索引做文档和它的词语的索引时，文档 ID 常被称为索引中的 “posting”。你可以将一个序列想成是一个文档，序列中的一对标签-值想做是文档中的词语。序列 ID -> 文档 ID，文档 ID -> posting，序列 ID -> posting。

每个条目中有序列的标签集和指向属于该序列的所有 chunks 的引用（这个引用就是 `chunks` 目录的那个）。

```
┌──────────────────────────────────────────────────────┐
│ len <uvarint>                                        │
├──────────────────────────────────────────────────────┤
│ ┌──────────────────────────────────────────────────┐ │
│ │            labels count <uvarint64>              │ │
│ ├──────────────────────────────────────────────────┤ │
│ │  ┌────────────────────────────────────────────┐  │ │
│ │  │ ref(l_i.name) <uvarint32>                  │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ ref(l_i.value) <uvarint32>                 │  │ │
│ │  └────────────────────────────────────────────┘  │ │
│ │                       ...                        │ │
│ ├──────────────────────────────────────────────────┤ │
│ │            chunks count <uvarint64>              │ │
│ ├──────────────────────────────────────────────────┤ │
│ │  ┌────────────────────────────────────────────┐  │ │
│ │  │ c_0.mint <varint64>                        │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ c_0.maxt - c_0.mint <uvarint64>            │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ ref(c_0.data) <uvarint64>                  │  │ │
│ │  └────────────────────────────────────────────┘  │ │
│ │  ┌────────────────────────────────────────────┐  │ │
│ │  │ c_i.mint - c_i-1.maxt <uvarint64>          │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ c_i.maxt - c_i.mint <uvarint64>            │  │ │
│ │  ├────────────────────────────────────────────┤  │ │
│ │  │ ref(c_i.data) - ref(c_i-1.data) <varint64> │  │ │
│ │  └────────────────────────────────────────────┘  │ │
│ │                       ...                        │ │
│ └──────────────────────────────────────────────────┘ │
├──────────────────────────────────────────────────────┤
│ CRC32 <4b>                                           │
└──────────────────────────────────────────────────────┘
```

起始的 `len` 和结尾的 `CRC32` 和前述的相同。序列条目以其中的标签-值对的数量开始，即 `labels count`，接着是字典序排列（按照标签名）的标签-值对。这里我们使用对符号表的符号引用，而不是把实际的字符串存起来。假如序列是 `{a="y", x="b"}`，那么它的序列条目会包括对 `"a", "y", "x", "b"` 的符号引用（以相同顺序）。

接下来是 `chunks` 目录中属于这个序列的 chunks 的数量（`chunks count`）。再接着是被索引的 chunks 的一系列元数据，包括 chunk 的最小时间（第一个 sample 的时间戳）和最大时间（最后一个 sample 的时间戳）和它在 `chunks` 目录中的引用。这些是按照 chunks 的 `mint` 排序的。如果你细看上面的格式，我们实际上是用对前一个的差值来存储 `mint` 和 `maxt` 的（相同 chunk 的mint 或者前一个 chunk 的maxt）。这会减少 chunk 元数据的大小，因为这占据了索引大小的一大部分。

在索引中存储 `mint` 和 `maxt` 使得查询可以跳过那些不在查询时间范围的 chunks。这和从磁盘做内存映射的 Head chunks 不同，那里 `mint` 和 `maxt` 是和 chunks 一起的，为了在启动期间重建 Head 的内存中索引。

---

#### D. `Label Offset Table` 和 `Label Index i`

这两项是耦合在一起的，所以我们放在一起讨论。`Label Index i` 指的是索引中的 `Label Index 1 ... Label Index N`；我们将讨论单个 `Label Index i` 条目。

**这两项已经不再使用了**；**写**它们是为了保持向后兼容，但是在最新版本的 Prometheus 中已经**不再读**它们了。然而，理解这些部分的用处还是有用的，我们将在下一部分看到它们被什么所取代。

这些部分的目的在于对标签名的可能的值做索引。例如，如果我们有两个序列 `{a="b1", x="y1"}` 和 `{a="b2", x="y2"}`，这部分使得我们可以得出，对于标签名 `a` 的可能的值是 `[b1, b2]`，而对于 `x` 可能的值是 `[y1, y2]`。这种格式也可以索引得出对于标签名 `(a, x)` 可能的值是 `[(b1, y1), (b2, y2)]`，但我们并没有在 Prometheus 中使用。

##### `Label Index i`

这是单个 `Label Index i` 条目的格式，我们有多个这种条目的序列，不过没有特定的顺序。

```
┌───────────────┬────────────────┬────────────────┐
│ len <4b>      │ #names <4b>    │ #entries <4b>  │
├───────────────┴────────────────┴────────────────┤
│ ┌─────────────────────────────────────────────┐ │
│ │ ref(value_0) <4b>                           │ │
│ ├─────────────────────────────────────────────┤ │
│ │ ...                                         │ │
│ ├─────────────────────────────────────────────┤ │
│ │ ref(value_n) <4b>                           │ │
│ └─────────────────────────────────────────────┘ │
│                      . . .                      │
├─────────────────────────────────────────────────┤
│ CRC32 <4b>                                      │
└─────────────────────────────────────────────────┘
```

根据上面的例子，这帮助我们存储 `[b1, b2], [y1, y2], [(b1, y1), (b2, y2)]` 列表，而每个列表在索引中都有其自己的条目。`len` 和 `CRC32` 和之前一样。

`#names` 是值对应的标签名的数量。例如，如果我们在对 `a` 或者 `x` 做索引，`#names` 就是1.而如果我们在对 `(a, x)` 做索引，即2个标签名，那么 `#names` 就是2。

`#entries` 是标签名的可能的值的数量。如果名称是 `a` 或者 `x`，甚至是 `(a, x)`，`#entries` 是2，因为它们每个都有2个可能的值。

接着的是 `#names * #entries` 个对值符号的引用。

以 `[b1, b2]` 为例：

```
┌────┬───┬───┬─────────┬─────────┬───────┐
│ 16 │ 1 │ 2 │ ref(b1) | ref(b2) | CRC32 |
└────┴───┴───┴─────────┴─────────┴───────┘
```

以 `[(b1, y1), (b2, y2)]` 为例：

```
┌────┬───┬───┬─────────┬─────────┬─────────┬─────────┬───────┐
│ 24 │ 2 │ 2 │ ref(b1) | ref(y1) │ ref(b2) | ref(y2) | CRC32 |
└────┴───┴───┴─────────┴─────────┴─────────┴─────────┴───────┘
```

##### `Label Offset Table`

`Label Index i` 储存了可能的值的列表，而 `Label Offset Table` 将标签名放在一起，并完成了标签名-值的索引。

`Label Offset Table` 的格式如下：

```
┌─────────────────────┬──────────────────────┐
│ len <4b>            │ #entries <4b>        │
├─────────────────────┴──────────────────────┤
│ ┌────────────────────────────────────────┐ │
│ │  n = 1 <1b>                            │ │
│ ├──────────────────────┬─────────────────┤ │
│ │ len(name) <uvarint>  │ name <bytes>    │ │
│ ├──────────────────────┴─────────────────┤ │
│ │  offset <uvarint64>                    │ │
│ └────────────────────────────────────────┘ │
│                    . . .                   │
├────────────────────────────────────────────┤
│  CRC32 <4b>                                │
└────────────────────────────────────────────┘
```

这里存储了从标签名指向它可能的值的一系列条目，例如，从 `a` 指向上述的包含 `[b1, b2]` 的 `Label Index i`。

上面的表中有类似其他部分的 `len` 和 `CRC32`。 `#entries` 是表中条目的数量。接下来的就是那些条目了。

每个条目以 `n` 开始，`n` 是标签名称的数量，紧接着的是 `n` 个实际的标签名而不是符号。你可能已经注意到了，字符串 `len(name) <uvarint> │ name <bytes>` 和在符号表中的存储方式一样。在 Prometheus 中，总是有 `n=1`，也就意味着我们仅仅对单个标签名称可能的标签值做索引，而不对类似于 `(a, x)` 的元组做索引，这是因为这种组合形式的可能值非常多，把它们存下来不太实际。

由于仅对单个标签名称做索引，而标签名的数量通常并不大，所以我们可以将字符串直接存储起来，避免了在查找标签名时从符号表加载磁盘页。

条目的最后是指向对应的 `Label Index i` 的文件偏移量。例如，对于标签名 `a`，这个偏移量会指向储存了 `[b1, b2]` 的 `Label Index i`。标签名 `x` 会指向储存了 `[y1, y2]` 的 `Label Index i`。

由于我们仅仅对单个标签名做索引，我们也就不会存储对应类似于元组 `(a, x)` 的 `Label Index i`，尽管在上文的例子中可见这是有可能做到的。曾经考虑过[实现这种复合型的标签值的索引](https://github.com/prometheus-junkyard/tsdb/issues/26)，但因为没有多少应用场景而放弃了。

#### E. `Postings Offset Table` 和 `Postings i`

和上一部分类似，这两项是联系在一起的，`Postings i` 储存了 postings 的列表，而 `Postings Offset Table` 通过偏移量引用了这些条目。如果你能回想起来， posting 就是序列 ID，在索引的上下文中就是序列条目在文件中的起始偏移量除以16，因为它是16字节对齐的。

##### `Postings i`

一个 `Postings i` 代表了一个 "postings list"，基本上就是一个 postings 的有序列表。我们来看看这样一个列表的格式，然后再用例子讲解下。

```
┌────────────────────┬────────────────────┐
│ len <4b>           │ #entries <4b>      │
├────────────────────┴────────────────────┤
│ ┌─────────────────────────────────────┐ │
│ │ ref(series_1) <4b>                  │ │
│ ├─────────────────────────────────────┤ │
│ │ ...                                 │ │
│ ├─────────────────────────────────────┤ │
│ │ ref(series_n) <4b>                  │ │
│ └─────────────────────────────────────┘ │
├─────────────────────────────────────────┤
│ CRC32 <4b>                              │
└─────────────────────────────────────────┘
```

这个格式不能再简单了。和往常一样，它同样有 `len` 和 `CRC32`。接着的是 `#entries`，即列表中 postings 的数量，然后是 `#entries` 个 postings（序列IDs，这里也是引用） 的有序列表。

你也许会好奇在这个列表中存储了哪些 postings。以这两个序列来举例：序列ID是 `120` 的 `{a="b", x="y1"}`，和序列ID是 `145` 的 `{a="b", x="y2"}`。类似于上文中我们是怎么查看一个标签名称可能的标签值的，这里我们对一个标签-值对查看可能的序列。对于上面的例子，`a="b"` 在两个序列中都出现了，所以我们需要存储列表 `[120, 145]`。对于 `x="y1"` 和 `x="y2"`，它们仅在其中一个序列中出现，所以我们对其分别存储 `[120]` 和 `[145]`。

我们仅对在序列中出现的标签对存储列表。所以在上面的例子中，我们不会对 `a="y1"` 或者 `x="b"` 存储 postings 列表，因为它们没有在序列中出现过。

##### `Postings Offset Table`

正如 `Label Offset Table` 将标签名指向在 `Label Index i` 中的可能值，`Postings Offset Table` 将标签对指向在 `Postings i` 中的可能的 postings。

```
┌─────────────────────┬──────────────────────┐
│ len <4b>            │ #entries <4b>        │
├─────────────────────┴──────────────────────┤
│ ┌────────────────────────────────────────┐ │
│ │  n = 2 <1b>                            │ │
│ ├──────────────────────┬─────────────────┤ │
│ │ len(name) <uvarint>  │ name <bytes>    │ │
│ ├──────────────────────┼─────────────────┤ │
│ │ len(value) <uvarint> │ value <bytes>   │ │
│ ├──────────────────────┴─────────────────┤ │
│ │  offset <uvarint64>                    │ │
│ └────────────────────────────────────────┘ │
│                    . . .                   │
├────────────────────────────────────────────┤
│  CRC32 <4b>                                │
└────────────────────────────────────────────┘
```

这看起来很像 `Label Offset Table` `len` 和 `CRC32` 和往常一样。

`#entries` 是表中条目的数量。`n` 总是2，表示紧接着的字符串元素的数量（即标签名和标签值）。由于 `n` 的存在，这个表可以索引复合的标签对，比如 `(a="b", x="y1")`，但我们不这样做，因为应用场景非常有限，而且不是一个好的权衡。

接着的是标签名和值的实际的字符串。再一次地，标签对的数量通常不会很多，所以我们可以将原始的字符串存放在这里，避免间接访问符号表，毕竟这张表会被访问很多次。符号表带来的主要节省来自于 `Series` 部分，该部分中很多符号都重复了很多次。

一个条目的结尾处是对应的 postings 列表 `Postings i` 的起始偏移量。上面的例子中，`name="a", value="b"` 的条目会指向 postings 列表 `[120, 145]`，而 `name="x", value="y1"` 的条目会指向 postings 列表 `[120]`。

这些条目是按照标签名和值排序的，首先是按照名称，然后对于相同名称的标签对按照值排序。这让我们可以对给定的标签对执行二分搜索。另外，要对于给定的标签名获取可能的值，我们可以先得到和标签名匹配的第一个标签对，然后以此开始迭代来获得所有标签值。因此，这个表取代了 `Label Offset Table` 和 `Label Index i`。 这也是另一个在这里存储实际的字符串的理由，这样可以更快地访问标签值。

postings 列表和 postings offset table 共同组成了反向索引。在使用反向索引来索引文档的场景中，对于每一个词我们存储了它出现过的所有文档的列表。类似地，对于每一个标签值对，我们存储了它出现过的所有序列的列表。

这就结束了篇幅超长的 `index` 部分。附上 `index` 格式的[文档链接](https://github.com/prometheus/prometheus/blob/master/tsdb/docs/format/index.md)。

### 4. `tombstones`

墓碑是删除的标记符，也就是说，它们表示在读数据时，哪个序列的哪个时间范围可以被忽略。这是 block 中唯一一个在写 block 后，为存储删除请求而创建和修改的文件。

墓碑文件格式：

```
┌────────────────────────────┬─────────────────────┐
│ magic(0x0130BA30) <4b>     │ version(1) <1 byte> │
├────────────────────────────┴─────────────────────┤
│ ┌──────────────────────────────────────────────┐ │
│ │                Tombstone 1                   │ │
│ ├──────────────────────────────────────────────┤ │
│ │                      ...                     │ │
│ ├──────────────────────────────────────────────┤ │
│ │                Tombstone N                   │ │
│ ├──────────────────────────────────────────────┤ │
│ │                  CRC<4b>                     │ │
│ └──────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────┘
```

`magic` 数字表示这是一个墓碑文件（猜猜这个数字是谁的生日？线索：一个实现了 TSDB 中删除功能的 Prometheus 维护者）。`version` 表示如何解析该文件。接着的是一系列墓碑，我们马上就会仔细看看它们。文件以所有墓碑的校验码(`CRC32`)结束。

每个墓碑形如：

```
┌────────────────────────┬─────────────────┬─────────────────┐
│ series ref <uvarint64> │ mint <varint64> │ maxt <varint64> │
└────────────────────────┴─────────────────┴─────────────────┘
```

第一个字段是该墓碑术语的序列引用（即序列 ID，也就是 posting）。`mint` 到 `maxt` 是删除指向的时间范围，所以我们在读 chunks 时应该跳过 `series ref` 指向的序列的这段时间范围。当单个序列有多个不相互重叠的删除的时间范围时，这会导致多个墓碑。

这是 `tombstone` 格式的[文档链接](https://github.com/prometheus/prometheus/blob/master/tsdb/docs/format/tombstones.md)。

## 尾声

在 Head block 的情况下，我们将反向索引和标签名与可能的值的映射高效地储存在内存中。

本文中我们已经看到了 block 在磁盘上的样子。特别是索引的详细情况，这也组成了本文的大部分。你也许会有很多问题，比如，索引中那些部分的作用，它们在查询中扮演了什么角色，哪种查询通常执行在 block 或者索引上，等等。

由于本文已经太长了，我们将在下一篇讨论查询的文章中看看这些问题。

## 代码参考

`tsdb/block.go` 有用于读写元数据文件的代码。其实这里有和持久化 block 有关的所有事情。

`tsdb/chunks/chunks.go` 有用于读取和写入 `chunks` 目录中的文件的代码。

`tsdb/index/index.go` 有用于读写索引文件的代码。

`tsdb/tombstones/tombstones.go` 有读取和写入墓碑文件的代码。

所有这些文件都指向了 block 的各个组件的实现。我们将在谈论查询和压缩的博文中看到在读写 block 时将所有这些结合在一起的代码。
