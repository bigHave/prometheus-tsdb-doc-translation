# Prometheus TSDB (Part 6): Compaction and Retention

原文地址：https://ganeshvernekar.com/blog/prometheus-tsdb-compaction-and-retention/

## 简介

当 Prometheus 创建出一些 blocks 后，我们需要经常地维护这些 blocks 来高效地利用磁盘并且保证查询的性能。

本文中，我们将探讨两个话题，压缩(compaction)和保留(retention)，两者都是当 Prometheus 运行时发生在后台的。

如果你还没有看过这个系列博客的之前的文章，为了更好的理解本文，建议先看下第一篇和第四篇博客。

## 压缩

压缩由这些步骤组成：根据一个或者多个存在的 blocks （称作源 block 或者父 block）创建一个新的 block，最后源 block 会被删除，而新的压缩的 block 将替代这些 blocks 被使用。

但是为什么需要压缩？

1. 正如我们在第四篇文章中看到的，对数据的删除是作为墓碑(tombstones)存放在一个单独的文件中的，而数据依然在磁盘上。所以当墓碑数量达到时序的某个百分占比时，我们需要将这部分数据从磁盘上移除。

2. 当数据搅动(churn)足够低时，相邻 blocks（是指时间维度的相邻）的索引中的大多数数据是相同的。所以通过将这些相邻的 blocks 压缩（合并），我们可以把缩阴中的一大部分去重掉，这样就能节省磁盘空间了。

3. 当一个查询打到超过一个 block 时，我们需要将各个 blocks 的结果做合并，而这会带来较大的开销(overhead)。通过合并相邻的 blocks，我们可以避免这种开销。

4. 如果有重叠的 blocks （是指时间维度的重叠），对它们的查询过程需要将 blocks 的 samples 做去重，而这比起仅仅连接不同 blocks 的 chunks 要昂贵得多。将这些重叠的 blocks 合并可以避免这类去重。

接下来说明发生一次压缩的两个步骤。每分钟我们发起一次压缩循环，首先对步骤1的结果做检查，只有当其不为空时才会进入到步骤2。这个压缩循环周期性地运行这些步骤，当步骤1为空时就会退出。

### 步骤1：“计划”

一个“计划“是一个将被压缩到一起的 blocks 的列表，这个列表是基于如下的条件按照从高到低的优先级挑选出来的。第一个满足的条件会生成一个“计划”，也就是说每个“计划”只有一个条件。当没有条件满足时，“计划”就是空的。

#### 条件1：重叠的 blocks

如上所述，重叠的 blocks 会导致查询变慢。Prometheus 自身不会产生重叠的 blocks，只有当你回填了一些数据到 Prometheus 时才会有。所以最高优先级的就是把这个重叠移除掉，回归到 Prometheus 本身会产生的状态。

这个“计划”可能有多于2个 blocks。例如：

```
|---1---|
            |---2---|
      |---3---|
                  |---4---|
```

虽然每个重叠只有2个 blocks，但是仔细看的话就会发现，当我们压缩一个重叠时，比如1和3，它们最终还是会和2重叠。所以与其经过几轮循环来修复这些重叠，不如在第一轮中就将 `[1 2 3 4]` 作为“计划”，减少压缩的次数。

另一个例子中产生的“计划”是 `[1 2 3]`

```
|-----1-----|
  |--2--|
     |----3----|  
```

注意，Prometheus 默认并不支持重叠的 blocks，如果有重叠的 blocks 的话，它会在启动或者运行时报错。使用 `--storage.tsdb.allow-overlapping-blocks` 来开启支持。

#### 条件2： 预设的时间范围

在这个条件下，我们挑选多于1个 block 合并，来填上一些预设的时间范围。在 Prometheus 中，默认的时间范围是 `[2h 6h 18h 54h 162h 486h]`，也就是从2h开始，依次乘以3。

以 `6h` 这个范围举例。我们将 Unix 时间划分为一些桶，如 `0-6h, 6h-12h, 12h-18h ...`，如果多于1个 block 落入其中任何一个桶，那就会形成一个“计划”，我们会把它们压缩到一起，产生一个最长6h的 block。

注意不要压缩最新的尚未持续整个桶的 blocks。例如，最新的2个2h范围的 blocks 不会被压缩在一起，因为它们：(1) 是新的，(2) 加起来没有持续6h。由于 Prometheus 生成2h的 blocks，当我们有>=3个 blocks 时，落入相同桶中的 blocks 会被压缩在一起。

类似地，我们检查所有时间范围，看看是否有任何时间桶中有多于1个block。在压缩周期结束时，对于所有时间范围都会将没有多于1个block的时间桶。

在 Prometheus 中，block 的最大大小是`31d`(即`744h`)和保留时间的十分之一中较低的。

#### 条件3：墓碑覆盖了序列的一定百分占比

最后，如果任何 block 的墓碑占 block 中总序列的多于5%，那么我们将对其进行压缩，将墓碑中指向的数据从磁盘中删除（通过创建一个没有被墓碑覆盖的 samples 的新block）。这将生成一个只有单 block 的“计划”。

### 步骤2：压缩

正如我们在第4篇文章中看到的，持久化的 block 是不可变的。要做任何改变，我们必须写一个新的 block。类似地，在压缩过程中，我们也是写一个全新的 block，即使它是对单 block 的压缩。压缩步骤只知道要压缩成单 block 的 blocks 列表，并不了解创建该“计划”所用的逻辑。

压缩逻辑随着时间的推移而发展，使用了各种内存管理技术，做到了更快的数据合并。从高层次看，通过以排序的方式逐个遍历序列（按照它们在索引中出现的顺序），对源 block 中的序列做N路合并。

<!-- 虽然在索引中对序列进行重复数据删除，但如果块没有重叠，则将从源块连接到一起。如果块存在重叠，则只对重叠的块进行不压缩，对样本进行删除(即只保留1个样本用于匹配时间戳)，压缩回>=1块，同时保持块的最大大小为120个样本。

如果在任何块中有墓碑，这些序列的块将被重写，以排除墓碑中提到的时间范围。最后一块没有墓碑。

每个压实块都有一个压实级别，它告诉块的生成，即块被压实的次数。对于新块，它是max(源块级别)+ 1。

如果一个系列的所有示例都被删除，那么该系列将从新块中完全跳过。如果块有0个样本(即空块)，那么当源块被删除时，没有块被写入磁盘。

请注意，压缩本身不会删除源块，而只是将它们标记为可删除(在它们的meta.json中)。在压缩周期结束后，TSDB分别处理新块的加载和源块的删除。 -->


## Head 压缩

这是一种特殊的压缩，其中源是 Head block，压缩将 Head block 的一部分持久化到持久 block 中，同时删除墓碑指向的任何数据。

第1篇文章阐述了 Head 压缩是何时完成的。Head block 实现了与持久化的 block 的 reader 相同的接口，因此我们使用相同的压缩代码将 Head block 压缩为持久 block。

从 Head block 产生的 block 的压缩级别是1。

## 保留

TSDB 允许设置保留策略来限制其中存储的数据量。有两种策略，分别是基于时间和基于大小的保留。你可以设置其中一个或两个。当同时设置两个时，两者之间是 `OR` 的关系，即满足其中一个时就会触发相关数据的删除。

### 基于时间的保留策略

该策略指定了 TSDB 中的数据时间跨度应该有多长。它是根据最新持久化的 block 的最大时间计算的相对时间跨度（而不是根据 Head block 计算的)。当一个 block **完全**超过时间保留期时，它将被删除，而不会在 block 其中一部分超过时间保留期时删除。

例如，如果保留期是`15d`，那么一旦最老的 block 的最大时间与最新的 block 的最大时间之间的差距超过 `15d`，这个最老的 block 就会被删除。

### 基于大小的保留策略

该策略指定了磁盘上 TSDB 的最大大小。它包括了 WAL、检查点、内存映射的 chunks 和持久化的 blocks。虽然我们把它们全部计入来决定是否删除，但是 WAL、检查点和内存映射的 chunks 对于 TSDB 的正常运行来说都是必需的。所以即使它们加在一起超过了保留大小，也只有 blocks 会被删除。因此，TSDB 占用的磁盘可能会超过指定的保留大小，如果策略设置得太小的话。

基于大小的保留策略比基于时间的保留策略更严格。只要占用的空间比最大大小多1个字节，最老的 block 就会被删除。


## 代码参考

[tsdb/compact.go](https://github.com/prometheus/prometheus/blob/master/tsdb/compact.go) 中有创建“计划”和压缩 blocks 的代码。

[storage/merge.go](https://github.com/prometheus/prometheus/blob/main/storage/merge.go) 中包含了用于连接/合并来自不同 blocks 的 chunks（包括重叠和非重叠的 chunks）的代码。

[tsdb/db.go](https://github.com/prometheus/prometheus/blob/master/tsdb/db.go) 中有每分钟启动压缩周期，对 blocks 进行前述的步骤1和步骤2，以及对 Head block 压缩的代码。还包含了两种保留类型的代码。
